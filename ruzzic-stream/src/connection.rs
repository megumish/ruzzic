use std::{cell::Ref, sync::Arc};

use rand::{prelude::StdRng, Fill, SeedableRng};
use ruzzic_common::{read_bytes_to::FromReadBytesWith, EndpointType};

use crate::{
    endpoint_state::EndpointState,
    packet::{self, Packet, PacketNumber, PacketPayload},
    Token, Version,
};

#[derive(Debug, Clone, PartialEq)]
pub struct ConnectionID(pub(crate) Vec<u8>);

impl FromReadBytesWith<()> for ConnectionID {
    fn from_read_bytes_with<R: std::io::Read>(input: &mut R, _: ()) -> Result<Self, std::io::Error>
    where
        Self: Sized,
    {
        unimplemented!()
    }
}

impl ConnectionID {
    pub fn to_vec(&self) -> Vec<u8> {
        self.0.clone()
    }

    pub(crate) fn len(&self) -> usize {
        self.0.len()
    }

    /// Connection IDs MUST NOT contain any information that can be used by an external observer(RFC 9000)
    /// So this is generated by cryptographically secure PRNG
    fn random() -> Self {
        // from_entrypy() function may cause some over-head.
        // https://docs.rs/rand/0.8.5/rand/trait.SeedableRng.html#method.from_entropy
        let mut rng = StdRng::from_entropy();
        let connection_id = {
            let mut id = Self(Vec::new());
            // try_fill() method may cause panic but not return some Error.
            id.try_fill(&mut rng).unwrap();
            id
        };
        connection_id
    }
}

const CONNECTION_ID_LENGTH: usize = 20;
impl Fill for ConnectionID {
    fn try_fill<R: rand::Rng + ?Sized>(&mut self, rng: &mut R) -> Result<(), rand::Error> {
        for i in 0..CONNECTION_ID_LENGTH {
            self.0.push(rng.gen());
        }
        Ok(())
    }
}

pub struct Connection {
    version: Version,
    destination_connection_id: ConnectionID,
    source_connection_id: ConnectionID,
    token: Token,
}

impl Connection {
    pub fn new_with_packet(version: Version, packet: Packet) -> Self {
        let destination_connection_id = packet.destination_connection_id().clone();
        let source_connection_id = packet
            .source_connection_id()
            .unwrap_or(ConnectionID::random());
        Connection {
            version,
            destination_connection_id,
            source_connection_id: source_connection_id,
            token: Token::empty(),
        }
    }

    pub(crate) fn next_packet_payload(&self) -> PacketPayload {
        PacketPayload::from_vec(Vec::new())
    }

    pub(crate) fn version(&self) -> &Version {
        &self.version
    }

    pub(crate) fn destination_connection_id(&self) -> &ConnectionID {
        &self.destination_connection_id
    }

    pub(crate) fn source_connection_id(&self) -> &ConnectionID {
        &self.source_connection_id
    }

    pub(crate) fn token(&self) -> &Token {
        &self.token
    }

    pub(crate) fn client_id(&self, endpoint_state: &EndpointState) -> &ConnectionID {
        match endpoint_state.type_is() {
            EndpointType::Server => &self.destination_connection_id,
            EndpointType::Client => &self.source_connection_id,
        }
    }
}
